// +FHDR -----------------------------------------------------------------------
// Copyright (c) Silicon Optronics. Inc. 2014
//
// File Name:           i2c_m_ctrl_trl.v
// Author:              Willy Lin
// Version:             $Revision$
// Last Modified On:    9/26
// Last Modified By:    $Author$
//
// File Description:    i2c master control block 
//                      
// Clock Domain: input:394k,1536k,2049k,3072k
//               output:106k,394k,512k,769k
// -FHDR -----------------------------------------------------------------------
module i2c_m_ctrl

   #( 
      parameter  NUM_WID     = 5
     )
(
//----------------------------------------------//
// Output declaration                           //
//----------------------------------------------//

output   reg                  o_sda_en,                     //use enable to control io_sda
output   reg                  o_scl_en,                     //use enable to control io_scl
output   reg                  o_finish_tgl,                 //when the transmit of trigger 0 is finish , toggle the finish signal 
output   reg                  o_nack_ntfy_tgl,              //when the transmit of trigger 1 encounter a nonack feedback , toggle the finish signal 
output   reg                  o_wr_data_wen, 
output        [7:0]           o_data_addr,
output   reg                  o_busy,   

output                        o_i2c_p2s_smo,                      
output                        o_i2c_data_sel_0_smo, 
output                        o_i2c_data_sel_1_smo, 
output   reg                  o_dev_id_dir,                 //change dirction of the transmit       
output                        o_p2s_dp_en,
output                        o_s2p_dp_en,   
        

//----------------------------------------------//
// Input declaration                            //
//----------------------------------------------//

input                         i2c_clk,
input                         i2c_rst_n,
input                         r_i2cm_type,                  //8a8d , 16a8d
input                         r_i2cm_nack,
input                         r_i2cm_stb,                   //open start byte or not
input                         r_i2cm_seq,                   //ramdom mode , sequencial mode 
input        [NUM_WID-1:0]    r_i2cm_num,                   //set how many data need to write or read 
input        [7:0]            r_i2cm_data_addr,             //this is address let i2c master know where to get the data 
input                         i_dev_id_msb,                 //be used to know the data direction 
input                         i_sda,                        //input sda
input                         i_scl,                        //input scl

input                         i_sxi_trg,                    //trigger 1 signal (rectify by cdc block)
input                         i_s_data                      //the internal signal from p2s . this signal will go to control the sda enable 
);

//----------------------------------------------//
// Local Parameter                              //
//----------------------------------------------//

localparam [10:0]  I2C_IDLE           = 11'b000_0000_0010,  //wait the trigger signal and clear all flag
                   I2C_START          = 11'b100_0000_0000,  //make the start signal for sda 
                   I2C_STB            = 11'b010_0000_0000,  //let sda send start signal 
                   I2C_STB_ACK        = 11'b000_0000_0100,  //wait start byte ack 
                   I2C_ID             = 11'b010_0000_1000,  //send device id with sda 
                   I2C_ID_ACK         = 11'b000_0100_1000,  //wait the id ack
                   I2C_STOP           = 11'b000_0010_0000,  //send the stop signal with sda 
                   I2C_WADDR          = 11'b010_0001_0001,  //write address to slave i2c 
                   I2C_WADDR_ACK      = 11'b000_0101_0000,  //wait for the waddr ack 
                   I2C_WR_DATA        = 11'b010_0001_0000,  //write data to i2c slave 
                   I2C_NUM_ACK        = 11'b001_0100_0000,  //only this status will go to stop or start status
                   I2C_RD_DATA        = 11'b000_1000_0000,  //read data from i2c slave 
                   I2C_RD_ACK         = 11'b001_0000_0000;  //send ack or nonack signal 



//----------------------------------------------//
// Register & Wire declaration                  //
//----------------------------------------------//

//---------------------------------------------fsm condition & flag
reg   [10:0]           i2c_m_cs;
reg   [10:0]           i2c_m_ns;
wire                   i2c_start_smo;
wire                   i2c_stop_smo;          
wire                   i2c_stb_smo;            
wire                   i2c_clr_smo; 
wire                   i2c_num_smo;          
wire                   i2c_s2p_smo;           
wire                   i2c_nack_smo;    
wire                   i2c_write_addr_smo;     
reg                    stb_flag;
wire                   stb_flag_nxt;
wire                   nack;
reg                    nack_flag;
wire                   nack_flag_nxt;
reg                    nack_flag2;
wire                   nack_flag2_nxt;
reg                    type_flag;
wire                   type_flag_nxt;
reg                    trg_flag;
wire                   trg_flag_nxt;
wire                   trans_8th;
reg                    trans_finish;
wire                   trans_finish_nxt;
wire                   o_dev_id_dir_nxt;
//---------------------------------------------output 
wire                   o_nack_ntfy_tgl_nxt;
wire                   o_finish_tgl_nxt;
wire                   o_scl_en_nxt;
wire                   o_sda_en_nxt;
wire                   o_wr_data_wen_nxt;
//---------------------------------------------others 
wire                   num_done;
reg                    i2c_clr_smo_q;
reg                    i2c_stop_smo_q;
wire                   trans_finish_pulse;
wire  [7:0]            addr_cnt_basic_nxt;
reg   [7:0]            addr_cnt_basic;
wire                   o_busy_nxt;
//---------------------------------------------counter 
reg   [NUM_WID-1:0]    num_cnt;
wire  [NUM_WID-1:0]    num_cnt_nxt;
wire                   num_cnt_inc;
wire                   num_cnt_clr;
reg   [7:0]            addr_cnt;
wire  [7:0]            addr_cnt_nxt;
wire                   addr_cnt_inc;
wire                   addr_cnt_set;
wire  [7:0]            addr_cnt_set_val;
reg   [1:0]            scl_cnt;
wire  [1:0]            scl_cnt_nxt;
wire                   scl_cnt_inc;
wire                   scl_cnt_clr;
reg   [2:0]            sda_cnt;
wire  [2:0]            sda_cnt_nxt;
wire                   sda_cnt_inc;
wire                   sda_cnt_clr;

//----------------------------------------------//
// Code Descriptions                            //
//----------------------------------------------//

//---------------fsm condition & flag

assign trg_flag_nxt        = (trg_flag | i_sxi_trg)   & ~(trans_finish_pulse);         // make flag wave of trigger 
assign stb_flag_nxt        = (stb_flag | i2c_stb_smo) & ~(i2c_clr_smo);  
assign nack_flag_nxt       = (nack_flag | nack) & ~(i2c_clr_smo);                      // nack flag wave 
assign nack_flag2_nxt      = ((nack_flag & nack) | nack_flag2) & ~(i2c_clr_smo);       // nack flag wave (the second times nack)
assign type_flag_nxt       = (type_flag | (trans_8th & i2c_write_addr_smo)) &          // set to 1 in waddr (16a8d)
                             ~(i2c_start_smo | i2c_clr_smo |                           // clear in start status or idle status 
                             (type_flag & trans_8th & i2c_write_addr_smo));            // clear flag in waddr when the flag already set to 1 
assign trans_8th           = (scl_cnt==2'h3) & (sda_cnt==3'h7) &            // when transmit to the eighth bit , this signal will set to one 
                             (o_i2c_p2s_smo | i2c_s2p_smo);                 // will enable when the status is I2C_STB or I2C_ID or I2C_WADDR or    
                                                                            // I2C_WR_DATA or I2C_RD_DATA
assign nack                = i2c_nack_smo & i_sda & scl_cnt==2'h3;          // in I2C_ID_ACK , I2C_NUM_ACK ,I2C_WADDR_ACK will detect the nonack  
assign trans_finish_nxt    = (trans_finish | num_done |                     // when num equal to r_i2cm_num , set to 1
                             (nack_flag  & r_i2cm_nack==1'b0) |             // the first time receive nack
                             (nack_flag2 & r_i2cm_nack)) &                  // the second time receive nack
                             ~(i2c_clr_smo);
assign trans_finish_pulse  = trans_finish &
                             i2c_stop_smo & scl_cnt==2'h3;    // in order to make the pulse 
assign o_dev_id_dir_nxt    = (o_dev_id_dir |
                             (i2c_nack_smo & i2c_num_smo & i_dev_id_msb & scl_cnt==2'h3)) &   // set to one in  NUM_ACK status (read address only)
                             ~(nack |                                                         //cannot swift when master receive a nack 
                             (i2c_num_smo & i2c_nack_smo==1'h0 & r_i2cm_seq==1'h0) |          // set to zero in RD_ACK status (random mode only)
                             i2c_clr_smo);                                                    // set to zero in IDLE status (random mode only)

//----------------output

assign o_scl_en_nxt        = ~(scl_cnt==2'h0 | scl_cnt==2'h3 ) |                                   // scl_en control by scl_cnt
                             (i2c_start_smo & (sda_cnt==3'h3 | sda_cnt==3'h4)) |                   // make start pulse
                             i2c_stop_smo_q | i2c_clr_smo_q;                                       // idle status,stop status
                                                                                                   // scl will keep to 1  
assign o_sda_en_nxt        = (i2c_start_smo & (sda_cnt < 3'h5)) |                                  // start signal 
                             ( o_i2c_p2s_smo & i_s_data) |                                         // according to p2s data 
                             i2c_s2p_smo |                                                         // in read data status 
                             (i2c_num_smo & i2c_nack_smo==1'h0 & (num_done | r_i2cm_seq==1'b0)) |  // in I2C_RD_ACK status
                             i2c_nack_smo |                                                        // status in ack , need to keep 1
                             (i2c_stop_smo & sda_cnt==3'h3)|                                       // in stop status
                             i2c_clr_smo ;                                                         // in idle status 

assign o_nack_ntfy_tgl_nxt = nack ^ o_nack_ntfy_tgl;                        // i2c master receive a non-ack signal , this signal will toggle
assign o_finish_tgl_nxt    = trans_finish_pulse  ^ o_finish_tgl;            // when transmit is finish , the toggle signal will be generated
assign o_wr_data_wen_nxt   = i2c_s2p_smo & trans_8th;                       // enable when the eighth data is parallel from serial

//----------------others

assign num_done            = trg_flag_nxt & (num_cnt_nxt == r_i2cm_num);    // set to one when all num is transmitting finish
assign o_p2s_dp_en         = (scl_cnt==2'h3) & o_i2c_p2s_smo;               // active p2s when status is in I2C_ID , I2C_WADDR , I2C_WR_DATA
assign o_s2p_dp_en         = (scl_cnt==2'h3) & i2c_s2p_smo;                 // active s2p when status is in I2C_RD_DATA status 
assign o_data_addr         = addr_cnt;
assign addr_cnt_basic_nxt  = ((i2c_write_addr_smo & type_flag_nxt==1'b0 & sda_cnt==3'h0) | i2c_clr_smo)? addr_cnt_nxt : addr_cnt_basic;
assign o_busy_nxt          = (trg_flag_nxt | o_busy) & ~(trans_finish_nxt & i2c_stop_smo & scl_cnt==2'h3);
//----------------counter 

assign num_cnt_nxt         = (num_cnt_inc ? num_cnt + 1'h1 : num_cnt) & {(NUM_WID){~num_cnt_clr}};
assign num_cnt_inc         = ((nack==1'h0 & i_dev_id_msb==1'h0) |           // when status is I2C_NUM_ACK and the slave respond ack  (only in write data)
                             (~i2c_nack_smo)) &                             // I2C_RD_ACK (only in read data)
                             scl_cnt_nxt==2'h0 & i2c_num_smo;                   // status in I2C_NUM_ACK,I2C_RD_ACK
assign num_cnt_clr         = trans_finish_pulse; 

assign addr_cnt_nxt        = addr_cnt_set ? addr_cnt_set_val : (addr_cnt_inc ? addr_cnt + 1'h1 : addr_cnt); 
assign addr_cnt_inc        = ((i2c_num_smo==1'h0 & i2c_nack_smo & o_i2c_data_sel_0_smo)  |   //in I2C_WADDR_ACK address count 1
                             (i2c_num_smo==1'h1)) &                                          //NUM_ACK and RD_ACK
                             scl_cnt==2'h0;                                                  //make a pulse 
assign addr_cnt_set        = nack | i2c_clr_smo;                                             //when the system receive a nack feedback , addr need get
                                                                                             //back to the I2C_WADDR status address 
assign addr_cnt_set_val    = i2c_clr_smo ? r_i2cm_data_addr: addr_cnt_basic;

assign scl_cnt_nxt         = (scl_cnt_inc ? scl_cnt+1'h1 : scl_cnt) & {2{~scl_cnt_clr}};
assign scl_cnt_inc         = ~i2c_clr_smo; 
assign scl_cnt_clr         = i2c_clr_smo;

assign sda_cnt_nxt         = (sda_cnt_inc ? sda_cnt+1'h1 : sda_cnt) & {3{~sda_cnt_clr}};
assign sda_cnt_inc         = i2c_start_smo |                                   // when status is in I2C_START , sda_cnt will start 
                             o_p2s_dp_en |                                     // in I2C_WR_DATA or I2C_WADDR or I2C_ID or I2C_STB , sda_cnt will start 
                             o_s2p_dp_en |                                     // when status is in I2C_RD_DATA , sda_cnt will start 
                             i2c_stop_smo;                                     // stop status 
assign sda_cnt_clr         = (i2c_start_smo & sda_cnt==3'h7) |                 // sda_cnt will reset when count to 4 in start status
                             trans_8th |                                       // set to 0 when data already transmit 8 bit data      
                             i2c_clr_smo;          

// ---------- State Machine --------------------//
assign  i2c_start_smo           = i2c_m_cs[10];
assign  o_i2c_p2s_smo           = i2c_m_cs[9];
assign  i2c_num_smo             = i2c_m_cs[8];
assign  i2c_s2p_smo             = i2c_m_cs[7];
assign  i2c_nack_smo            = i2c_m_cs[6];
assign  i2c_stop_smo            = i2c_m_cs[5];
assign  o_i2c_data_sel_0_smo    = i2c_m_cs[4];
assign  o_i2c_data_sel_1_smo    = i2c_m_cs[3];
assign  i2c_stb_smo             = i2c_m_cs[2];
assign  i2c_clr_smo             = i2c_m_cs[1];
assign  i2c_write_addr_smo      = i2c_m_cs[0];          

always @* begin : I2C_M_FSM
  i2c_m_ns = i2c_m_cs; 


  case (i2c_m_cs)
    I2C_IDLE: 

             if(trg_flag_nxt) 
               i2c_m_ns = I2C_START;
               
    I2C_START:

             begin 
               if (sda_cnt==3'h7) begin
                  if(r_i2cm_stb==1'h1 & stb_flag==1'h0)
                    i2c_m_ns = I2C_STB;
                  else
                    i2c_m_ns = I2C_ID;
               end
             end

    I2C_STB:

             if (trans_8th) 
               i2c_m_ns = I2C_STB_ACK;

    I2C_STB_ACK:

             if (scl_cnt==2'h3) 
                i2c_m_ns = I2C_START;

    I2C_ID:
             if (trans_8th) 
                i2c_m_ns = I2C_ID_ACK;

    I2C_ID_ACK:

             begin 
               if (scl_cnt==2'h3) begin
                 if (nack)
                   i2c_m_ns = I2C_STOP;
                 else begin
                   if(o_dev_id_dir)
                     i2c_m_ns = I2C_RD_DATA;         
                   else
                     i2c_m_ns = I2C_WADDR; 
                 end
               end
             end

    I2C_STOP:

             begin 
               if (scl_cnt==2'h3) begin
                 if(trans_finish_nxt)
                   i2c_m_ns =I2C_IDLE;
                 else
                   i2c_m_ns =I2C_START;
               end
             end

    I2C_WADDR:

             begin 
               if (trans_8th) begin
                 if(i_dev_id_msb & (type_flag == r_i2cm_type))
                   i2c_m_ns = I2C_NUM_ACK;
                 else 
                   i2c_m_ns = I2C_WADDR_ACK;
               end
             end

    I2C_WADDR_ACK:

             begin 
               if (scl_cnt==2'h3) begin
                 if(nack)
                   i2c_m_ns = I2C_STOP;
                 else begin
                   if (type_flag ^ r_i2cm_type)
                     i2c_m_ns = I2C_WR_DATA;
                   else
                     i2c_m_ns = I2C_WADDR; 
                 end
               end
             end

    I2C_WR_DATA:

             begin 
               if (trans_8th) 
                 i2c_m_ns = I2C_NUM_ACK;
             end

    I2C_NUM_ACK:

             begin 
               if (scl_cnt==2'h3) begin
                 if(trans_finish_nxt | nack)
                   i2c_m_ns =I2C_STOP;
                 else begin
                   if(i_dev_id_msb==1'h0 & r_i2cm_seq)
                     i2c_m_ns = I2C_WR_DATA;
                   else
                     i2c_m_ns = I2C_START;
                 end
               end
             end

    I2C_RD_DATA:

             begin 
               if (trans_8th) 
                 i2c_m_ns = I2C_RD_ACK;
             end

    I2C_RD_ACK:

             begin 
               if (scl_cnt==2'h3) begin
                 if(trans_finish_nxt)
                   i2c_m_ns =I2C_STOP;
                 else begin
                   if(r_i2cm_seq)
                     i2c_m_ns =I2C_RD_DATA;
                   else
                     i2c_m_ns =I2C_START;
                 end
               end
             end

  endcase 

end


always @(posedge i2c_clk or negedge i2c_rst_n) begin
   if (~i2c_rst_n) 
    i2c_m_cs          <= 11'b000_0000_0010;
   else
    i2c_m_cs          <= i2c_m_ns; 
end


always @(posedge i2c_clk or negedge i2c_rst_n) begin
   if (~i2c_rst_n) begin

//---------------------------------------------fsm condition & flag
    stb_flag          <= 1'h0;
    nack_flag         <= 1'h0;
    nack_flag2        <= 1'h0;
    type_flag         <= 1'h0;
    trg_flag          <= 1'h0;
    o_dev_id_dir      <= 1'h0;
    i2c_clr_smo_q     <= 1'h1;
    i2c_stop_smo_q    <= 1'h0;
    trans_finish      <= 1'h0;
    o_busy            <= 1'h0;
//---------------------------------------------output
    o_nack_ntfy_tgl   <= 1'h0;
    o_finish_tgl      <= 1'h0;
    o_sda_en          <= 1'h0;
    o_scl_en          <= 1'h0;
    o_wr_data_wen     <= 1'h0;
//---------------------------------------------counter 
    num_cnt           <= {(NUM_WID){1'h0}};
    scl_cnt           <= 2'h0;
    sda_cnt           <= 3'h0;
    addr_cnt          <= {(NUM_WID){1'h0}};
    addr_cnt_basic    <= 8'h0;

   end
   else begin

//---------------------------------------------fsm condition & flag
    stb_flag          <= stb_flag_nxt;
    nack_flag         <= nack_flag_nxt;
    nack_flag2        <= nack_flag2_nxt;
    type_flag         <= type_flag_nxt;
    trg_flag          <= trg_flag_nxt;
    o_dev_id_dir      <= o_dev_id_dir_nxt;
    i2c_clr_smo_q     <= i2c_clr_smo;
    i2c_stop_smo_q    <= i2c_stop_smo;
    trans_finish      <= trans_finish_nxt;
    o_busy            <= o_busy_nxt;
//---------------------------------------------output 
    o_nack_ntfy_tgl   <= o_nack_ntfy_tgl_nxt;
    o_finish_tgl      <= o_finish_tgl_nxt;
    o_sda_en          <= o_sda_en_nxt;
    o_scl_en          <= o_scl_en_nxt;
    o_wr_data_wen     <= o_wr_data_wen_nxt; 
//---------------------------------------------counter 
    num_cnt           <= num_cnt_nxt;
    scl_cnt           <= scl_cnt_nxt;
    sda_cnt           <= sda_cnt_nxt;
    addr_cnt          <= addr_cnt_nxt;
    addr_cnt_basic    <= addr_cnt_basic_nxt;

   end
end

endmodule 
